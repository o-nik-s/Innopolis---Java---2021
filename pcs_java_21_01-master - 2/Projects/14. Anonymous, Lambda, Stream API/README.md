# 1.7 - 1.8

## Анонимные классы

* Позволяют сделать код более лаконичным.

* Если какая-то функциональность нужна здесь и сейчас, то лучше воспользоваться
анонимным классом.

* Создается единственный экземпляр такого класса.

* Имеет доступ к членам класса, на основе которого он создан.

* Должен реализовать ВСЕ абстрактные методы.

* Можно переопределить поведение методов, на основе которых создан данный класс.

* Имеет доступ к переменным обрамляющего кода.

## Лямбда-выражения

* Функциональный интерфейс - это интерфейс, содержащий только один 
метод.

* По сути, реализация (анонимная) таких интерфейсов содержат объявление
только одного метода. Следовательно, можно сильно упростить запись с помощью лябмда-выражения.

* Лямбда-выражения - создаются на основе функционального интерфейса и представляют собой 
реализацию единственного метода этого интерфейса.

## Различия между лямбда-выражениями (ЛВ) и анонимными классами (АК)

* АК - класс без имени, ЛВ - метод без имени.

* АК - создается на основе класса (абстрактного, либо обычного, интерфейса), допускает реализацию множества методов.

* ЛВ - см. выше

* `this` для АК - это ссылка на объект абстрактного класса, для ЛВ `this` - это ссылка на объект внешнего класса.

## Некоторые моменты из Stream API + Lambda

```
sorted(Comparator<? super T> comparator);

В метод sorted можно передать лямбду, которая реализует метод:
int compare(T o1, T o2);

Мы передали вот такую конструкцию, что она означает?

Comparator.comparingInt(String::length)

public static <T> Comparator<T> comparingInt(ToIntFunction<? super T> keyExtractor) {
        Objects.requireNonNull(keyExtractor);
        return (Comparator<T> & Serializable)
            (c1, c2) -> Integer.compare(keyExtractor.applyAsInt(c1), keyExtractor.applyAsInt(c2));
    }

Что мы передаем в качестве keyExtractor? keyExtractor -> String::length

Почему?

Потому что в keyExtractor есть метод int applyAsInt(T value); 

return (Comparator<T>) (c1, c2) -> (x < y) ? -1 : ((x == y) ? 0 : 1);
```
