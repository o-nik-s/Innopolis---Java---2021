# 1.9

[Ссылка для скачивания файла](https://www.stats.govt.nz/large-datasets/csv-files-for-download/)
## Многопоточность

* Процесс - приложение, у каждого процесса своя область памяти и набор потоков.

* Поток вычислений - элемент процесса.

### Методы потоков:

* `start()` - запуск потока.

* `Thread.currentThread()` - получить экземпляр текущего потока.

* `Thread.sleep()` - усыпляет текущий поток.

### Дополнительно

* `synchronize(e)` - занимает мьютекс `e`, и пока не освободит его, другой поток, ожидающий выполнения какой-либо операции не сможет ничего делать.

* `wait` - уводит поток в ожидание на каком-либо объекте до тех пор, пока у этого объекта не вызовут `notify`.

* `notify` - выводит поток из ожидания на объекте, у которого был вызван данный метод.

### Реализация `TaskExecutorThreadPerTask`

* На каждую задачу мы создаем и завершаем новый поток. Старт и завершение потока - дорогая операция.

### Реализация `WorkerThread`

* Не нужно создавать и завершать потоки, используем побочный поток. Минусы - он только один.

### Реализация `ThreadPool`

* Создаем n-ое количество потоков, а затем делегируем им задачи.

### Классы для работы с многопоточностью

* `FutureTask` - позволяет получить результат поточной операции.

* `Exchanger` - позволяет организовать точку синхронизации между двумя потоками для обмена данных.

![Exchanger](img/exchanger.gif)

* `Semaphore` - позволяет организовать выполнение ограниченного количества потоков одновременно.

![Semaphore](img/semaphore.gif)

* `CyclicBarrier` - позволяет реализовать барьер для потоков (уходят в ожидание, пока не разрешит барьер).

![CyclicBarrier](img/cyclic_barrier.gif)

* `CountDownLatch` - позволяет организовать ожидание потоков и их последующий запуск.

![CountDownLatch](img/count_down_latch.gif)